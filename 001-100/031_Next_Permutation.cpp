/*找一堆数字字典序更大的下一个排列，如果这种安排不可能，则必须将其重新排列为尽可能低的顺序（即按升序排序）。要求替换必须就地，并且仅使用恒定的额外内存。
比如：
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
我的方法是倒着找比当前数字小的一个数，把他们交换位置，在把从交换位置开始的后面的元素排序，这样能找到下一个字典序。
但是会出现问题，比如[4,2,0,2,3,2,0]，倒着看，0在前面找不到比它小的，2在前面可以找到索引为2的0，交换后[4,2,2,2,3,0,0]，对索引2后面进行排序，得到
[4,2,2,0,0,2,3],但是实际上可以交换3,4位置的2和3，得到[4,2,0,3,2,2,0],在对后面进行排序得到[4,2,0,3,0,2,2],这才是下一个字典序。
因此先找到每个元素的往前比它小的下一个元素，再比较，得到最靠后的一个，进行交换和排序操作。不可能找到下一个字典序，即数组已经是从大到小排序，翻转数组
得到从小到大即可。C++中可以用swap函数进行元素交换，reverse函数进行数组的翻转
*/
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i,j=0,k=nums.size()-1;
        map <int,int> a;
        for(i=nums.size()-1;i>0;i--)
        {
          a[i]=-1;
          for(j=i-1;j>=0;j--)
          if(nums[i]>nums[j])
          {
            a[i]=j;
            break;
          }
        }
        j=-1;
        for(i=nums.size()-1;i>0;i--)
        {if(a[i]!=-1&&a[i]>j) {j=a[i];k=i;}}
        if(j!=-1)
        {
         swap(nums[k],nums[j]);//交换
         j++;
        }
        else j=0;
        reverse(nums.begin()+j,nums.end());//数组翻转
    }
}; 
